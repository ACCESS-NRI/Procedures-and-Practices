{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"All procedure and practice policies for ACCESS-NRI are available on this website. Policies are markdown documents in a GitHub repository that are automatically rendered into HTML and viewable on the Procedures and Practices website . These procedures and practices define the scope of what ACCESS-NRI does and how it does it. The policies are living documents, open to the community and feedback is welcome. Direct feedback is one avenue for the community to have a say in how the ACCESS-NRI operates. The best way to give feedback is to open an issue on this repository. Info See GitHub docs: creating an issue from a repository The site contains pages for each procedure or practice policy document. These are grouped into broad sections, but the entire site is searchable which should make finding relevant material relatively painless.","title":"Welcome"},{"location":"technical/code_and_workflow_platform_strategy/","text":"Code and Workflow Management Strategy Executive Summary For code hosting the proposal is to use public GitHub repositories, where code licensing allows, and ZenHub for workflow management. See below for a summary of design criteria and comments on how these are met with the chosen tools. Note that the UM Atmosphere model has strict licensing conditions that do not allow it to be hosted on publicly available services. It also uses Subversion for version control. There were always going to be issues with integrating the UM for these reasons, so the decision was made to choose tools to be as open as possible and integrate as smoothly as possible with existing communities and deal with the UM as a special case. Code hosting: Criteria Compliance Publicly accessible Public GitHub repositories (where licensing allows) are viewable without an account Low barrier to community participation GitHub currently hosts all targeted open source model components Version control software GitHub is based around git, the industry standard distributed version control system Code review tools Github pull requests (PRs) include support for code review, optionally this can be made mandatory Community can report bugs/ask for changes GitHub Issues Community can suggest code changes GitHub pull requests support code contributions from community Continuous integration/testing GitHub workflows are highly configurable and tightly integrated with code review and pull requests Workflow management: Criteria Compliance Visible to the community ZenHub uses GitHub permissions, so read-only access will allow viewing the workflow and current progress Zenhub works directly with GitHub issues, still publicly visible Open source is free, so will scale seamlessly to however many community members need access Organise work across multiple repositories Zenhub supports multirepository workspaces across organisations Support agile workflows ZenHub is highly configurable and expressly supports agile development: Sprints, Epics, Planning poker, Velocity estimation Project planning and tracking functionality ZenHub provides high level roadmaps, burndown charts and other tools for measuring productivity ZenHub provides dedicated release support, projects and epics for work planning High level reporting tools ZenHub roadmap and release functionality On time delivery ZenHub includes extensive support for agile development, planning and reporting, enabling timely delivery Introduction ACCESS-NRI (NRI) has a requirement to develop climate, weather and earth-system research models for the Australian community. These models consist of complex scientific code bases for multiple model components and associated documentation. Excellent software development practices and powerful tools are required to properly manage such a complex software ecosystem. Community building is a foundational requirement of the NRI and an important determinant in its success. Building a community requires high levels of trust in the outputs of the NRI, and excellent communication between the NRI and stakeholders. This leads to some fundamental guiding principles: Open and transparent Responsive to community needs Trust in the work of the NRI is essential. Trust can be engendered by the following approaches: Best practice software development Well tested, validated and reproducible models Full provenance of models and model output Well supported products On time release delivery Requirements for Code Development Tools Best practice software development includes using modern version control systems, continuous integration (CI) testing, code review and excellent documentation. There is a hierarchy of testing and typically it is compilation > unit > run > reproducibility > performance. Code review is also an important element in producing robust model code that the community can trust. Reproducibility is essential. It provides a check on code change correctness. If a model cannot reproduce answers this has to be understood and documented. Users need to know if model changes lead to changes in model answers in the case where they need to reproduce earlier experiments. Model performance, running time, memory use etc, need to be tracked. Significant reductions in performance must be detected in automated testing, investigated and remedied if possible. Where performance reductions are unavoidable, they also need to be documented to enable users to make informed decisions about which model version they need to use for their work. For version control, Git is preferred to SVN as it is the industry standard. By choosing Git-based repositories, the developers can take advantage of a plethora of development tools with Git integrations that do not exist for SVN. Full provenance for a released experiment means, for a given data product being able to determine exact source code version build process, including versions of all supporting libraries model inputs Model inputs themselves require full provenance, including identifying the original source data and all transformations required to produce the files used in the model. The goal is to be able to reproducibly build the model and re-run an experiment and reproduce the earlier results. This means users can trust they can always identify how their experiment was run and reproduce the results when necessary. Another goal is that users can take well documented NRI experiments and create modified versions for examining their own scientific questions. In this way the NRI can improve the productivity and impact of the Australian research community. NRI development activities must be responsive to community needs. The code needs to be easily accessible to the community. Members of the community must be able to lodge bug reports, feature requests and report omissions in documentation. The process for doing so must be straightforward and well understood. A well-supported product must have excellent documentation and timely resolution of errors, omissions or bugs. The NRI is supporting community models, this means the community will actively participate in the development of the models and software curated by the NRI. As such, the code development tools must be accessible by the whole community and easy to learn and operate. Requirements summary Category Requirements Development Open to collaboration from the community Open, transparent bug reporting Low barrier to community participation Git version control if possible Testing CI compilation testing Run testing Reproducibility testing Performance testing Provenance Code version control Code review Support for code review during update Proposed Strategy For git-based repositories, there are currently 3 different well-known platforms: Bitbucket , Gitlab and GitHub . The proposal is to use GitHub for all open source code repositories. GitHub is already the platform used by all the open source model components the NRI intends to use in the initial tranche of releases. Part of the community knows how to use it and there are well designed online training courses available to all, which means a low barrier to participate. As the code is already on GitHub there is the option to use component code directly from the current repository. This is potentially easier and meshes the NRI activities tightly with those of existing communities. Even in the case where NRI creates a fork of an existing repository the original and the fork are tightly coupled and it is straightforward to synchronise changes between them. GitHub issue support is excellent. It is easy to use, familiar to some in the community, and offers many features that nicely tie issues together, even across repositories and organisations. Code updates are possible through pull requests, from either NRI staff, or directly from the community. This process is well understood by part of the community. Pull requests (PRs) can trigger continuous integration (CI) testing, which can be configured so the code cannot be merged without first passing CI testing. Pull requests can be connected to issues and automatically close an issue when the PR code is merged. Features like this help in streamlining code development. Code review is supported in PRs, and can also be configured such that code cannot be merged without first passing the code review. Supporting the UM in this environment is complex. The code will have to remain on the UKMO Subversion server. To integrate work on the UM as closely as possible a UM repository will be created. It will not link to code, but will contain issues so that work on the UM can be managed in the same framework as the other model components. Community members can also lodge their issues in this repository, removing the need to create a UKMO account. We will use GitHub to release configurations for the UM model component. These configuration repositories will contain all information and auxiliary tools needed to build and run the configuration. Strategy compliance See Executive summary above. Requirements for Workflow Management Tools ACCESS-NRI operates in a complex software environment. Typically a model will contain code from many separate repositories, in some cases those repositories may not reside in the same location. The NRI will also have to collaborate with existing model developers in the community. Flagship releases will require collaboration between most NRI teams: model development, model verification, training and release. All input from the community will come in the form of issues and pull requests in the relevant code repositories. Consequently a workflow management tool must: be configurable to deal with different workflow requirements, work across multiple repositories in multiple organisations, and link very closely to the issues in the code repositories. Accurate and informative reporting tools, and transparent workflow management allow the community to keep abreast of progress. Being open with development progress gives the community confidence in release timelines. On time release delivery will show the community that the NRI is able to follow through on commitments and can be a trusted partner in their research program. Timely release in large complex software projects has been proven to be a very difficult task with traditional project management techniques. Agile software development is best suited to accurately estimate and meet software delivery timelines. Requirements summary Category Requirements Project management Flexibility for different tasks Automated workflow tools Support different projects, releases and epic High level reporting tools, e.g. roadmaps Issues and PRs Tight integration Agile development Planning poker for timing estimates Sprint planning and execution Velocity estimate (burndown charts etc) Community On time delivery Open to the community Proposed Strategy GitHub has a project management tool, called GitHub Projects, included with GitHub repositories. However, this tool is quite simple and does not work across more than one repository. As such, it is not suitable for our purpose. Gitlab and Bitbucket come also with integrated project management tools. These tools are very good, but they did not provide enough of an advantage for us to choose these platforms. The proposal strategy is to use ZenHub for code workflow management. ZenHub is built to work on top of GithHub, either as a standalone web application, or as a plugin to the Chrome browser working directly on the GitHub website. It uses GitHub issues directly, and seamlessly integrates them into the ZenHub workflow. The issues themselves are still visible on GitHub without using ZenHub. ZenHub supports creating multiple workspaces with the same repositories. Each workspace can be configured to give a different view of the repositories, and with entirely different workflow setup. ZenHub supports automatic workflows between workspaces. Thus ZenHub is highly configurable and customisable for different tasks. ZenHub supports different categories of task grouping: releases, projects and epics. It has high level reporting tools showing the progress of releases and projects. ZenHub supports agile development and includes planning poker, sprint planning and executtion, velocity estimates for better release timeline planning and burndown charts for tracking spring progress. Strategy compliance See Executive summary above.","title":"Code and Workflow Management"},{"location":"technical/code_and_workflow_platform_strategy/#code-and-workflow-management-strategy","text":"","title":"Code and Workflow Management Strategy"},{"location":"technical/code_and_workflow_platform_strategy/#executive-summary","text":"For code hosting the proposal is to use public GitHub repositories, where code licensing allows, and ZenHub for workflow management. See below for a summary of design criteria and comments on how these are met with the chosen tools. Note that the UM Atmosphere model has strict licensing conditions that do not allow it to be hosted on publicly available services. It also uses Subversion for version control. There were always going to be issues with integrating the UM for these reasons, so the decision was made to choose tools to be as open as possible and integrate as smoothly as possible with existing communities and deal with the UM as a special case. Code hosting: Criteria Compliance Publicly accessible Public GitHub repositories (where licensing allows) are viewable without an account Low barrier to community participation GitHub currently hosts all targeted open source model components Version control software GitHub is based around git, the industry standard distributed version control system Code review tools Github pull requests (PRs) include support for code review, optionally this can be made mandatory Community can report bugs/ask for changes GitHub Issues Community can suggest code changes GitHub pull requests support code contributions from community Continuous integration/testing GitHub workflows are highly configurable and tightly integrated with code review and pull requests Workflow management: Criteria Compliance Visible to the community ZenHub uses GitHub permissions, so read-only access will allow viewing the workflow and current progress Zenhub works directly with GitHub issues, still publicly visible Open source is free, so will scale seamlessly to however many community members need access Organise work across multiple repositories Zenhub supports multirepository workspaces across organisations Support agile workflows ZenHub is highly configurable and expressly supports agile development: Sprints, Epics, Planning poker, Velocity estimation Project planning and tracking functionality ZenHub provides high level roadmaps, burndown charts and other tools for measuring productivity ZenHub provides dedicated release support, projects and epics for work planning High level reporting tools ZenHub roadmap and release functionality On time delivery ZenHub includes extensive support for agile development, planning and reporting, enabling timely delivery","title":"Executive Summary"},{"location":"technical/code_and_workflow_platform_strategy/#introduction","text":"ACCESS-NRI (NRI) has a requirement to develop climate, weather and earth-system research models for the Australian community. These models consist of complex scientific code bases for multiple model components and associated documentation. Excellent software development practices and powerful tools are required to properly manage such a complex software ecosystem. Community building is a foundational requirement of the NRI and an important determinant in its success. Building a community requires high levels of trust in the outputs of the NRI, and excellent communication between the NRI and stakeholders. This leads to some fundamental guiding principles: Open and transparent Responsive to community needs Trust in the work of the NRI is essential. Trust can be engendered by the following approaches: Best practice software development Well tested, validated and reproducible models Full provenance of models and model output Well supported products On time release delivery","title":"Introduction"},{"location":"technical/code_and_workflow_platform_strategy/#requirements-for-code-development-tools","text":"Best practice software development includes using modern version control systems, continuous integration (CI) testing, code review and excellent documentation. There is a hierarchy of testing and typically it is compilation > unit > run > reproducibility > performance. Code review is also an important element in producing robust model code that the community can trust. Reproducibility is essential. It provides a check on code change correctness. If a model cannot reproduce answers this has to be understood and documented. Users need to know if model changes lead to changes in model answers in the case where they need to reproduce earlier experiments. Model performance, running time, memory use etc, need to be tracked. Significant reductions in performance must be detected in automated testing, investigated and remedied if possible. Where performance reductions are unavoidable, they also need to be documented to enable users to make informed decisions about which model version they need to use for their work. For version control, Git is preferred to SVN as it is the industry standard. By choosing Git-based repositories, the developers can take advantage of a plethora of development tools with Git integrations that do not exist for SVN. Full provenance for a released experiment means, for a given data product being able to determine exact source code version build process, including versions of all supporting libraries model inputs Model inputs themselves require full provenance, including identifying the original source data and all transformations required to produce the files used in the model. The goal is to be able to reproducibly build the model and re-run an experiment and reproduce the earlier results. This means users can trust they can always identify how their experiment was run and reproduce the results when necessary. Another goal is that users can take well documented NRI experiments and create modified versions for examining their own scientific questions. In this way the NRI can improve the productivity and impact of the Australian research community. NRI development activities must be responsive to community needs. The code needs to be easily accessible to the community. Members of the community must be able to lodge bug reports, feature requests and report omissions in documentation. The process for doing so must be straightforward and well understood. A well-supported product must have excellent documentation and timely resolution of errors, omissions or bugs. The NRI is supporting community models, this means the community will actively participate in the development of the models and software curated by the NRI. As such, the code development tools must be accessible by the whole community and easy to learn and operate.","title":"Requirements for Code Development Tools"},{"location":"technical/code_and_workflow_platform_strategy/#requirements-summary","text":"Category Requirements Development Open to collaboration from the community Open, transparent bug reporting Low barrier to community participation Git version control if possible Testing CI compilation testing Run testing Reproducibility testing Performance testing Provenance Code version control Code review Support for code review during update","title":"Requirements summary"},{"location":"technical/code_and_workflow_platform_strategy/#proposed-strategy","text":"For git-based repositories, there are currently 3 different well-known platforms: Bitbucket , Gitlab and GitHub . The proposal is to use GitHub for all open source code repositories. GitHub is already the platform used by all the open source model components the NRI intends to use in the initial tranche of releases. Part of the community knows how to use it and there are well designed online training courses available to all, which means a low barrier to participate. As the code is already on GitHub there is the option to use component code directly from the current repository. This is potentially easier and meshes the NRI activities tightly with those of existing communities. Even in the case where NRI creates a fork of an existing repository the original and the fork are tightly coupled and it is straightforward to synchronise changes between them. GitHub issue support is excellent. It is easy to use, familiar to some in the community, and offers many features that nicely tie issues together, even across repositories and organisations. Code updates are possible through pull requests, from either NRI staff, or directly from the community. This process is well understood by part of the community. Pull requests (PRs) can trigger continuous integration (CI) testing, which can be configured so the code cannot be merged without first passing CI testing. Pull requests can be connected to issues and automatically close an issue when the PR code is merged. Features like this help in streamlining code development. Code review is supported in PRs, and can also be configured such that code cannot be merged without first passing the code review. Supporting the UM in this environment is complex. The code will have to remain on the UKMO Subversion server. To integrate work on the UM as closely as possible a UM repository will be created. It will not link to code, but will contain issues so that work on the UM can be managed in the same framework as the other model components. Community members can also lodge their issues in this repository, removing the need to create a UKMO account. We will use GitHub to release configurations for the UM model component. These configuration repositories will contain all information and auxiliary tools needed to build and run the configuration.","title":"Proposed Strategy"},{"location":"technical/code_and_workflow_platform_strategy/#strategy-compliance","text":"See Executive summary above. Requirements for Workflow Management Tools ACCESS-NRI operates in a complex software environment. Typically a model will contain code from many separate repositories, in some cases those repositories may not reside in the same location. The NRI will also have to collaborate with existing model developers in the community. Flagship releases will require collaboration between most NRI teams: model development, model verification, training and release. All input from the community will come in the form of issues and pull requests in the relevant code repositories. Consequently a workflow management tool must: be configurable to deal with different workflow requirements, work across multiple repositories in multiple organisations, and link very closely to the issues in the code repositories. Accurate and informative reporting tools, and transparent workflow management allow the community to keep abreast of progress. Being open with development progress gives the community confidence in release timelines. On time release delivery will show the community that the NRI is able to follow through on commitments and can be a trusted partner in their research program. Timely release in large complex software projects has been proven to be a very difficult task with traditional project management techniques. Agile software development is best suited to accurately estimate and meet software delivery timelines.","title":"Strategy compliance"},{"location":"technical/code_and_workflow_platform_strategy/#requirements-summary_1","text":"Category Requirements Project management Flexibility for different tasks Automated workflow tools Support different projects, releases and epic High level reporting tools, e.g. roadmaps Issues and PRs Tight integration Agile development Planning poker for timing estimates Sprint planning and execution Velocity estimate (burndown charts etc) Community On time delivery Open to the community","title":"Requirements summary"},{"location":"technical/code_and_workflow_platform_strategy/#proposed-strategy_1","text":"GitHub has a project management tool, called GitHub Projects, included with GitHub repositories. However, this tool is quite simple and does not work across more than one repository. As such, it is not suitable for our purpose. Gitlab and Bitbucket come also with integrated project management tools. These tools are very good, but they did not provide enough of an advantage for us to choose these platforms. The proposal strategy is to use ZenHub for code workflow management. ZenHub is built to work on top of GithHub, either as a standalone web application, or as a plugin to the Chrome browser working directly on the GitHub website. It uses GitHub issues directly, and seamlessly integrates them into the ZenHub workflow. The issues themselves are still visible on GitHub without using ZenHub. ZenHub supports creating multiple workspaces with the same repositories. Each workspace can be configured to give a different view of the repositories, and with entirely different workflow setup. ZenHub supports automatic workflows between workspaces. Thus ZenHub is highly configurable and customisable for different tasks. ZenHub supports different categories of task grouping: releases, projects and epics. It has high level reporting tools showing the progress of releases and projects. ZenHub supports agile development and includes planning poker, sprint planning and executtion, velocity estimates for better release timeline planning and burndown charts for tracking spring progress.","title":"Proposed Strategy"},{"location":"technical/code_and_workflow_platform_strategy/#strategy-compliance_1","text":"See Executive summary above.","title":"Strategy compliance"},{"location":"technical/documentation_platform_strategy/","text":"Executive Summary We are proposing to put in place a Documentation Hub, ACCESS-Hub , powered by MkDocs . ACCESS-Hub will provide links to the documentation supported by the ACCESS NRI and any documentation the ACCESS community deems useful. It will group and clearly identify which documentation is supported by the ACCESS NRI and that supported by the community. The technical documentation supported by the ACCESS NRI will either use ReadTheDocs (RTD) or MkDocs + GitHub pages . ReadTheDocs is preferred for automated API documentation, or strict versioning is required. MkDocs is preferred when the barrier to contribution needs to be as low as possible. Other documentation will make use of other tools and platforms as appropriate for the type of communication (e.g. Jupyter Notebooks and Books, YouTube, etc.). See below for a summary of how the proposed strategy complies with the identified requirements Criteria Compliance Limit the number of platforms for supported documentation MkDocs + GitHub pages and RTD Clear delineation between NRI curated and community-led organisation Separate community GitHub documentation Clear separation of supported and community docs on ACCESS-Hub Documentation contained within a model code repository Docs in model repo where possible subject to licensing Contributions from a wide range of people: NRI staff and the community experts Publicly visible git repository allows input via issues and pull request ACCESS-Hub conduit for community contributions Support of code snippets Code snippets supported by all plaforms Standalone documentation with its own versioning if required RTD versioning is tempo customisable Support a limited range of formats for NRI supported documentation Sphinx very widely used. Other systems can generate compatible docs if required e.g. jupyterbook. Otherwise default to Markdown Ease of use by the community GitHub issues and pull requests are well known and currently used in community Markdown is a simple and easy to use markup language that is very widely used. e.g. GitHub ACCESS-Hub can link to documentation in any form. So documentation software systems with lower barrier of entry can be used if necessary Introduction ACCESS-NRI (NRI) has a requirement to provide documentation to the community as a component of release packages. Some of that documentation will need to be sourced from the community, who are the domain specialists. The NRI can also play a very important role by providing a common location for other related documentation generated by the community. There needs to be a clear distinction between documentation supported by the NRI, and other documentation that is not supported but is recognised to be of value to the community. Requirements for the Documentation NRI Supported Documentation All release packages require extensive documentation. This documentation can be broken down into two broad groups: User focused documentation: describes how to use items in the release package, such as running models or analysing model output data. This category includes any documentation produced for training purposes. As such it can use a wide range of formats to support different types of communication (e.g. code-based, video, text). Technical documentation: describes technical detail that is of interest to a narrow audience with specialist knowledge. This can be further subdivided into Versioned documentation that resides in the same repository as model component code, and is updated in lock-step to reflect changes to the code Other technical documentation that is less closely tied to rapidly varying and versioned codebases, e.g. documentation relating to the generation of input data such as bathymetry More general documentation such as policies and practices It is important that versioned technical documentation is identifiable by version, so that it is straightforward to find the technical documentation that relates to an exact version of a model. This also ensures versioned technical documentation does not become stale or out of date as can happen if a single documentation source is used to cover all model versions. Other technical documentation exists on an update cycle that is not necessarily strictly tied to code changes. Such as example python notebooks and general How-To guides. These items will need to be periodically updated and will have their own versioning tempo to facilitate updates and backwards compatibility, but it is unlikely to change with the same rapidity. This documentation may only need to be revised with major model or configuration updates and may share some of the same version numbers as models or configurations to which it is closely aligned but will likely have many fewer total versions. This makes it easier for users to ensure they are using the correct version of the documentation. More general documentation does not require formal versioning. It is essential that the community can easily provide feedback on the documentation and propose changes. Current documentation work by the NRI must also be clearly visible to the community. Versioned technical documentation will be the industry standard ReadTheDocs , otherwise MkDocs + Github Pages as this is simple and easy to use, lowering the barrier for community input. This means all documentation supported by the NRI will be hosted in public git repositories, either within a model component repository or a standalone documentation repository. It will allow the community and the NRI to communicate on the state of the documentation through the same issue process as for the model development work. Community Produced Documentation There is immense value to the broader community to have a single curated location for documentation beyond what is provided and supported by the NRI. There is also value to the NRI, as a source of information from the community, who are domain specialists. Much of the community produced documentation exists in many different formats, on a variety of platforms, such as wikis and legacy websites, that do not have a guaranteed long-term future. Documentation that has value for the community will need to be migrated to a stable platform. The NRI needs a solution that provides clear delineation between NRI released and supported documentation, and community produced documentation that the NRI has neither the remit nor resources to actively support. We also need a solution that does not impose an undue burden on community members that do not have the time to spare, as this would limit community engagement. Requirements summary Category Requirements General requirements Limit the number of platforms (ideally 1). Clear delineation between NRI curated and community-led documentation. Technical documentation -- versioning in lock-step with model Documentation contained within a model code repository model Contributions from a wide range of people: NRI staff and the community experts Support of code snippets Technical documentation -- with own versioning Standalone documentation with its own versioning tempo Support a limited range of formats Contributions from a wide range of people: NRI staff and the community experts User focused documentation Standalone documentation with its own versioning tempo Support a limited range of formats Contributions from a wide range of people: NRI staff and the community experts Community-led documentation Ease of use by the community Support a wide variety of formats Proposed Strategy The proposal is for ACCESS-Hub : a central one-stop-shop for documentation, where anyone can go and quickly find links to either NRI supported documentation or community produced documentation. The ACCESS-NRI website will have an obvious link to ACCESS-Hub , but the hub will be a git-based Material for MkDocs + Github Pages site for a number of reasons: More responsive to update than the website Best practice versioning with git Open to the community: anyone can lodge issues if there are errors or updates and propose updates through pull requests Curated by the NRI, which makes documentation visible and credible Platform agnostic: only consists of links to existing websites, no direct hosting of community documentation Markdown is simple to write, lowering barrier to contributions Github Pages is easy, and is clearly associated with the GitHub repo where changes are made Material for MkDocs has an excellent built-in live search capability Links to documentation will be clearly sorted into NRI supported and community documentation. In addition, there will be further separation into broad categories, perhaps aligned to working groups. Entries will be annotated to indicate the nature of the material, and Material for MkDocs has excellent live searching which allows for discovery via the annotations. All the documentation supported by ACCESS-NRI will be created under separate sites on the main ACCESS-NRI GitHub Organization and linked to from the ACCESS-Hub . Community produced documentation can be hosted on any platform chosen by the community since the Hub approach has the advantage of being platform agnostic, which means it will be relatively quick to create. Having ACCESS-Hub in a GitHub repo site makes updates easy and open to the community. This aligns with agile philosophy: create a product as quickly as possible and then iterate and improve. It also scales well, with little additional overhead for adding links to more material. ACCESS-Hub will make gathering information for NRI supported documentation easier, which is a key objective. In some cases, large sections of existing documentation will be able to be reused, or transferred, to the NRI supported documentation. One possible downside is a lack of consistency between community generated documentation, both in quality and format. However, the NRI will showcase best practices for documentation, which can be emulated. Excellent community sourced documentation will also act as exemplars for the broader community. Included in the ACCESS-Hub will be instructions on how to contribute and suggestions for documentation platforms that are suitable, including software solutions for those for whom MkDocs would be technically challenging and present a barrier to community involvement. There may be some legacy documentation that is valuable to the community but is no longer supported or maintained and in danger of disappearing. Depending on value, and difficulty level, it may be possible for the NRI, or the community with NRI assistance, to transition legacy documentation to an RTD site, or similar. However the NRI will explicitly have no role in on-going support. As part of this strategy ACCESS-Hub will be hosted under it's own community ACCESS-Hub GitHub Organization where community generated or legacy documentation can also reside. This provides a host for any community documentation that has no other obvious location, or if the community sees value in hosting their documentation in a shared space. Having a separate community GitHub organisation simplifies administration and permissions compared to hosting community resources on the main ACCESS-NRI GitHub Organization . It also provides a focal point for collaboration and community building around the ACCESS-NRI. Strategy compliance Refer to the Executive Summary for a table outlining how the proposed strategy complies with the stated requirements.","title":"Documentation Platform"},{"location":"technical/documentation_platform_strategy/#executive-summary","text":"We are proposing to put in place a Documentation Hub, ACCESS-Hub , powered by MkDocs . ACCESS-Hub will provide links to the documentation supported by the ACCESS NRI and any documentation the ACCESS community deems useful. It will group and clearly identify which documentation is supported by the ACCESS NRI and that supported by the community. The technical documentation supported by the ACCESS NRI will either use ReadTheDocs (RTD) or MkDocs + GitHub pages . ReadTheDocs is preferred for automated API documentation, or strict versioning is required. MkDocs is preferred when the barrier to contribution needs to be as low as possible. Other documentation will make use of other tools and platforms as appropriate for the type of communication (e.g. Jupyter Notebooks and Books, YouTube, etc.). See below for a summary of how the proposed strategy complies with the identified requirements Criteria Compliance Limit the number of platforms for supported documentation MkDocs + GitHub pages and RTD Clear delineation between NRI curated and community-led organisation Separate community GitHub documentation Clear separation of supported and community docs on ACCESS-Hub Documentation contained within a model code repository Docs in model repo where possible subject to licensing Contributions from a wide range of people: NRI staff and the community experts Publicly visible git repository allows input via issues and pull request ACCESS-Hub conduit for community contributions Support of code snippets Code snippets supported by all plaforms Standalone documentation with its own versioning if required RTD versioning is tempo customisable Support a limited range of formats for NRI supported documentation Sphinx very widely used. Other systems can generate compatible docs if required e.g. jupyterbook. Otherwise default to Markdown Ease of use by the community GitHub issues and pull requests are well known and currently used in community Markdown is a simple and easy to use markup language that is very widely used. e.g. GitHub ACCESS-Hub can link to documentation in any form. So documentation software systems with lower barrier of entry can be used if necessary","title":"Executive Summary"},{"location":"technical/documentation_platform_strategy/#introduction","text":"ACCESS-NRI (NRI) has a requirement to provide documentation to the community as a component of release packages. Some of that documentation will need to be sourced from the community, who are the domain specialists. The NRI can also play a very important role by providing a common location for other related documentation generated by the community. There needs to be a clear distinction between documentation supported by the NRI, and other documentation that is not supported but is recognised to be of value to the community.","title":"Introduction"},{"location":"technical/documentation_platform_strategy/#requirements-for-the-documentation","text":"","title":"Requirements for the Documentation"},{"location":"technical/documentation_platform_strategy/#nri-supported-documentation","text":"All release packages require extensive documentation. This documentation can be broken down into two broad groups: User focused documentation: describes how to use items in the release package, such as running models or analysing model output data. This category includes any documentation produced for training purposes. As such it can use a wide range of formats to support different types of communication (e.g. code-based, video, text). Technical documentation: describes technical detail that is of interest to a narrow audience with specialist knowledge. This can be further subdivided into Versioned documentation that resides in the same repository as model component code, and is updated in lock-step to reflect changes to the code Other technical documentation that is less closely tied to rapidly varying and versioned codebases, e.g. documentation relating to the generation of input data such as bathymetry More general documentation such as policies and practices It is important that versioned technical documentation is identifiable by version, so that it is straightforward to find the technical documentation that relates to an exact version of a model. This also ensures versioned technical documentation does not become stale or out of date as can happen if a single documentation source is used to cover all model versions. Other technical documentation exists on an update cycle that is not necessarily strictly tied to code changes. Such as example python notebooks and general How-To guides. These items will need to be periodically updated and will have their own versioning tempo to facilitate updates and backwards compatibility, but it is unlikely to change with the same rapidity. This documentation may only need to be revised with major model or configuration updates and may share some of the same version numbers as models or configurations to which it is closely aligned but will likely have many fewer total versions. This makes it easier for users to ensure they are using the correct version of the documentation. More general documentation does not require formal versioning. It is essential that the community can easily provide feedback on the documentation and propose changes. Current documentation work by the NRI must also be clearly visible to the community. Versioned technical documentation will be the industry standard ReadTheDocs , otherwise MkDocs + Github Pages as this is simple and easy to use, lowering the barrier for community input. This means all documentation supported by the NRI will be hosted in public git repositories, either within a model component repository or a standalone documentation repository. It will allow the community and the NRI to communicate on the state of the documentation through the same issue process as for the model development work.","title":"NRI Supported Documentation"},{"location":"technical/documentation_platform_strategy/#community-produced-documentation","text":"There is immense value to the broader community to have a single curated location for documentation beyond what is provided and supported by the NRI. There is also value to the NRI, as a source of information from the community, who are domain specialists. Much of the community produced documentation exists in many different formats, on a variety of platforms, such as wikis and legacy websites, that do not have a guaranteed long-term future. Documentation that has value for the community will need to be migrated to a stable platform. The NRI needs a solution that provides clear delineation between NRI released and supported documentation, and community produced documentation that the NRI has neither the remit nor resources to actively support. We also need a solution that does not impose an undue burden on community members that do not have the time to spare, as this would limit community engagement.","title":"Community Produced Documentation"},{"location":"technical/documentation_platform_strategy/#requirements-summary","text":"Category Requirements General requirements Limit the number of platforms (ideally 1). Clear delineation between NRI curated and community-led documentation. Technical documentation -- versioning in lock-step with model Documentation contained within a model code repository model Contributions from a wide range of people: NRI staff and the community experts Support of code snippets Technical documentation -- with own versioning Standalone documentation with its own versioning tempo Support a limited range of formats Contributions from a wide range of people: NRI staff and the community experts User focused documentation Standalone documentation with its own versioning tempo Support a limited range of formats Contributions from a wide range of people: NRI staff and the community experts Community-led documentation Ease of use by the community Support a wide variety of formats","title":"Requirements summary"},{"location":"technical/documentation_platform_strategy/#proposed-strategy","text":"The proposal is for ACCESS-Hub : a central one-stop-shop for documentation, where anyone can go and quickly find links to either NRI supported documentation or community produced documentation. The ACCESS-NRI website will have an obvious link to ACCESS-Hub , but the hub will be a git-based Material for MkDocs + Github Pages site for a number of reasons: More responsive to update than the website Best practice versioning with git Open to the community: anyone can lodge issues if there are errors or updates and propose updates through pull requests Curated by the NRI, which makes documentation visible and credible Platform agnostic: only consists of links to existing websites, no direct hosting of community documentation Markdown is simple to write, lowering barrier to contributions Github Pages is easy, and is clearly associated with the GitHub repo where changes are made Material for MkDocs has an excellent built-in live search capability Links to documentation will be clearly sorted into NRI supported and community documentation. In addition, there will be further separation into broad categories, perhaps aligned to working groups. Entries will be annotated to indicate the nature of the material, and Material for MkDocs has excellent live searching which allows for discovery via the annotations. All the documentation supported by ACCESS-NRI will be created under separate sites on the main ACCESS-NRI GitHub Organization and linked to from the ACCESS-Hub . Community produced documentation can be hosted on any platform chosen by the community since the Hub approach has the advantage of being platform agnostic, which means it will be relatively quick to create. Having ACCESS-Hub in a GitHub repo site makes updates easy and open to the community. This aligns with agile philosophy: create a product as quickly as possible and then iterate and improve. It also scales well, with little additional overhead for adding links to more material. ACCESS-Hub will make gathering information for NRI supported documentation easier, which is a key objective. In some cases, large sections of existing documentation will be able to be reused, or transferred, to the NRI supported documentation. One possible downside is a lack of consistency between community generated documentation, both in quality and format. However, the NRI will showcase best practices for documentation, which can be emulated. Excellent community sourced documentation will also act as exemplars for the broader community. Included in the ACCESS-Hub will be instructions on how to contribute and suggestions for documentation platforms that are suitable, including software solutions for those for whom MkDocs would be technically challenging and present a barrier to community involvement. There may be some legacy documentation that is valuable to the community but is no longer supported or maintained and in danger of disappearing. Depending on value, and difficulty level, it may be possible for the NRI, or the community with NRI assistance, to transition legacy documentation to an RTD site, or similar. However the NRI will explicitly have no role in on-going support. As part of this strategy ACCESS-Hub will be hosted under it's own community ACCESS-Hub GitHub Organization where community generated or legacy documentation can also reside. This provides a host for any community documentation that has no other obvious location, or if the community sees value in hosting their documentation in a shared space. Having a separate community GitHub organisation simplifies administration and permissions compared to hosting community resources on the main ACCESS-NRI GitHub Organization . It also provides a focal point for collaboration and community building around the ACCESS-NRI.","title":"Proposed Strategy"},{"location":"technical/documentation_platform_strategy/#strategy-compliance","text":"Refer to the Executive Summary for a table outlining how the proposed strategy complies with the stated requirements.","title":"Strategy compliance"},{"location":"technical/reproducibility_and_performance_testing_organisation/","text":"Introduction Official GitHub repositories need to be public for maximum visibility to the ACCESS Community. Reproducibility and performance testing will have to be run offsite on self-hosted runners on HPC hardware . GitHub recommends not using self-hosted on public repositories : We recommend that you only use self-hosted runners with private repositories. This is because forks of your repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow. The CI needs to be configured to mitigate the security issues with self-hosted runners on public repositories to an acceptable risk level. What are the major risks? Threat injection into software affecting users Disruption to activities and wasted time and energy assessing damage Reputational damage Disruption/deletion of material at HPC Compromise of HPC accounts Threat Identification As noted above the major threat vector is a pull request (PR) from a fork of a public repository which contains malicious code. A major threat, with low likelihood, is a GitHub account of an Organisation admin or maintainer being compromised. A minor threat is an inadvertent change to CI configuration from a trusted user or source that enables a major threat. Threat Mitigation Summary Action Platform Comments 2FA Authentication GitHub Admins and maintainers of ACCESS-NRI repos Admin GitHub Repo admin rights restricted to team lead and above IF REQUIRED Maintainer GitHub Repo maintainer rights restricted to team members IF REQUIRED GITHUB_TOKEN GitHub Reduce default permissions Open dev GitHub Public PR to dev branch only Protected main GitHub PR to main only from members of designated team Require 2 reviews Only signed commits Do not allow bypassing branch protection settings GitHub environment GitHub Require designated team approval for HPC CI tests Reusable workflows GitHub Less error prone Cleaner Isolates changes to CI in more secure repo Service user HPC Run jobs as service user. Reduces attack surface, severity of attack and account compromise JobFS HPC Run job entirely in ephemeral JobFS space on compute nodes. Reduces possibility of harmful artefacts. Pre-run checks HPC Have independent script run pre-run checks before jobs submitted. Containers HPC Run entirely inside singularity containers. Massively reduce attack surface with read-only mounts Audit HPC Run post-run audit to check for anomalous behaviour Apply the principle of least privilege . GitHub Require all admins and maintainers of the ACCESS-NRI organisation or repositories to enable two-factor authentication (2FA) to minimise threat of compromised accounts. Team lead and above will have admin status if required . Everyone else maintainer status if required . Elevated privileges are a responsibility that requires work to understand the ramifications of actions. It should be a relief not to have to shoulder that burden. Reduce default permissions for GITHUB_TOKEN to prevent malicious use of API requests . GitHub defaults to not running CI on a PR from a first-time contributor and requires authorisation from a maintainer to run the workflow. This can be circumvented by submitting an innocuous PR which is authorised for CI, and then push subsequent malicious code to the PR branch. It is also possible for a trusted contributor GitHub account to be compromised and start a PR with malicious code. So while these defaults are worthwhile they are not sufficient. As it is insufficient to rely on default protections, offsite self-hosted runners must either only run workflows from specified protected branches or only run after approval from nominated team members (or both). Option A - Protected branch: Allow public PR to dev branch which runs only GitHub CI compilation checks. CI with self-hosted runners is restricted to PRs to the main branch which is protected and only allows a PR from dev from designated team members. Suggested branch protection rules on main branch for security purposes (other branch protection rules are appropriate but for code quality reasons): Require pull request (no direct pushes) Require 2 reviews before merging Prevent force-push Prevent branch deletion, or creation of matching branches Allow only signed commits Do not allow bypassing branch protection settings Signed commits are important. It is trivially easy to impersonate another user when committing to git. This does lead to elevated privileges, but could be exploited in a social hack, causing commits to be accepted based on an assumption of identity. A drawback of this approach is code gets committed to the dev branch without other checks, such as reproducibility. These checks would only be run on a subsequent PR to the main branch. This violates the scrum dictum to fix bugs as quickly as possible. One way to address this (though it adds complexity) is to automatically create a PR to main when approvals pass, and make the original PR dependent on the new PR passing. This would mean code gets added to main before dev, which is not intuitive. Option B -- Environment approval: Define a GitHub environment (e.g. \"reproducibility\") which requires specified team sign-off. Allow public PR to main branch which runs only GitHub CI compilation checks by default, and use environment: reproducibility in workflow specification for offsite (self-hosted) checks. Pull requests are run with the base repo of the PR, so the CI yaml can't be directly altered for the PR checks themselves. A weakness of this approach is that human error could miss malicious or unintentionally harmful modification that removes the environment specification so that subsequent PRs will run without sign-off. Option C -- Protected branch and environment approval: Combine option A and B. Only allow PR to a dev branch, and use GitHub environment to require approval for offsite (self-hosted) runs with PR from dev to main. This is the most secure option. It doesn't stop harmful changes to the CI, but there is an extra level of checks to navigate and a team member has to initiate the PR, so it can't happen automatically. Option B is the simplest and easiest for Community members as it requires no work on their part. Option C is the most secure, but it does require pull requests to be made against a specific branch that is not the default branch. It is possible to change the default branch , which is the default branch used for PRs, but it is also the default branch used for git clone and displayed on the web interface. Reusable workflows are workflow yaml files that can be reused in repositories. Should strongly prefer to use reusable workflows in CI: Reduces technical debt in CI (improvements automatically propagated to all CI) Isolates major CI changes to a repository with much higher security Less error prone Possibility of running CI checks for changes to GitHub workflow configuration. HPC (Runners) Run as a service user. Reduces the potential for harmful attack and inadvertent changes to a user environment which may introduce more attack possibilities. Also reduces the damage in the case of account compromise. Run entirely in ephemeral PBS jobfs space. Reduces the potential for harmful or malicious artefacts to persist and be reused. Use automated pre-run script to make some consistency checks, e.g. job name matches allowed list. This has the advantage of being completely independent of the repository code, and not visible to malicious actors. This also means the script needs to be kept in sync with tests, but this is a feature not a bug: can't just run new tests without some oversight. Could have a post-run script in the same way, which is an opportunity to run some security checks. Singularity containers can be used at NCI . Containers can reduce the attack surface for malicious code, particularly using user-bind to create read-only mounts. Use automated post-run script to do post-run audit. Could reduce privileges of service user to prevent writing, or deleting, from important directory trees. This is problematic, as it is fragile and prone to inadvertent change. It should not be relied upon, so should probably not be used. Auditing Log information on files generated, runtime and memory usage to spot anomalous activity. Run cron workflows to check repo settings are correct.","title":"Reproducibility and Performance Testing"},{"location":"technical/reproducibility_and_performance_testing_organisation/#introduction","text":"Official GitHub repositories need to be public for maximum visibility to the ACCESS Community. Reproducibility and performance testing will have to be run offsite on self-hosted runners on HPC hardware . GitHub recommends not using self-hosted on public repositories : We recommend that you only use self-hosted runners with private repositories. This is because forks of your repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow. The CI needs to be configured to mitigate the security issues with self-hosted runners on public repositories to an acceptable risk level. What are the major risks? Threat injection into software affecting users Disruption to activities and wasted time and energy assessing damage Reputational damage Disruption/deletion of material at HPC Compromise of HPC accounts","title":"Introduction"},{"location":"technical/reproducibility_and_performance_testing_organisation/#threat-identification","text":"As noted above the major threat vector is a pull request (PR) from a fork of a public repository which contains malicious code. A major threat, with low likelihood, is a GitHub account of an Organisation admin or maintainer being compromised. A minor threat is an inadvertent change to CI configuration from a trusted user or source that enables a major threat.","title":"Threat Identification"},{"location":"technical/reproducibility_and_performance_testing_organisation/#threat-mitigation","text":"Summary Action Platform Comments 2FA Authentication GitHub Admins and maintainers of ACCESS-NRI repos Admin GitHub Repo admin rights restricted to team lead and above IF REQUIRED Maintainer GitHub Repo maintainer rights restricted to team members IF REQUIRED GITHUB_TOKEN GitHub Reduce default permissions Open dev GitHub Public PR to dev branch only Protected main GitHub PR to main only from members of designated team Require 2 reviews Only signed commits Do not allow bypassing branch protection settings GitHub environment GitHub Require designated team approval for HPC CI tests Reusable workflows GitHub Less error prone Cleaner Isolates changes to CI in more secure repo Service user HPC Run jobs as service user. Reduces attack surface, severity of attack and account compromise JobFS HPC Run job entirely in ephemeral JobFS space on compute nodes. Reduces possibility of harmful artefacts. Pre-run checks HPC Have independent script run pre-run checks before jobs submitted. Containers HPC Run entirely inside singularity containers. Massively reduce attack surface with read-only mounts Audit HPC Run post-run audit to check for anomalous behaviour Apply the principle of least privilege .","title":"Threat Mitigation"},{"location":"technical/reproducibility_and_performance_testing_organisation/#github","text":"Require all admins and maintainers of the ACCESS-NRI organisation or repositories to enable two-factor authentication (2FA) to minimise threat of compromised accounts. Team lead and above will have admin status if required . Everyone else maintainer status if required . Elevated privileges are a responsibility that requires work to understand the ramifications of actions. It should be a relief not to have to shoulder that burden. Reduce default permissions for GITHUB_TOKEN to prevent malicious use of API requests . GitHub defaults to not running CI on a PR from a first-time contributor and requires authorisation from a maintainer to run the workflow. This can be circumvented by submitting an innocuous PR which is authorised for CI, and then push subsequent malicious code to the PR branch. It is also possible for a trusted contributor GitHub account to be compromised and start a PR with malicious code. So while these defaults are worthwhile they are not sufficient. As it is insufficient to rely on default protections, offsite self-hosted runners must either only run workflows from specified protected branches or only run after approval from nominated team members (or both). Option A - Protected branch: Allow public PR to dev branch which runs only GitHub CI compilation checks. CI with self-hosted runners is restricted to PRs to the main branch which is protected and only allows a PR from dev from designated team members. Suggested branch protection rules on main branch for security purposes (other branch protection rules are appropriate but for code quality reasons): Require pull request (no direct pushes) Require 2 reviews before merging Prevent force-push Prevent branch deletion, or creation of matching branches Allow only signed commits Do not allow bypassing branch protection settings Signed commits are important. It is trivially easy to impersonate another user when committing to git. This does lead to elevated privileges, but could be exploited in a social hack, causing commits to be accepted based on an assumption of identity. A drawback of this approach is code gets committed to the dev branch without other checks, such as reproducibility. These checks would only be run on a subsequent PR to the main branch. This violates the scrum dictum to fix bugs as quickly as possible. One way to address this (though it adds complexity) is to automatically create a PR to main when approvals pass, and make the original PR dependent on the new PR passing. This would mean code gets added to main before dev, which is not intuitive. Option B -- Environment approval: Define a GitHub environment (e.g. \"reproducibility\") which requires specified team sign-off. Allow public PR to main branch which runs only GitHub CI compilation checks by default, and use environment: reproducibility in workflow specification for offsite (self-hosted) checks. Pull requests are run with the base repo of the PR, so the CI yaml can't be directly altered for the PR checks themselves. A weakness of this approach is that human error could miss malicious or unintentionally harmful modification that removes the environment specification so that subsequent PRs will run without sign-off. Option C -- Protected branch and environment approval: Combine option A and B. Only allow PR to a dev branch, and use GitHub environment to require approval for offsite (self-hosted) runs with PR from dev to main. This is the most secure option. It doesn't stop harmful changes to the CI, but there is an extra level of checks to navigate and a team member has to initiate the PR, so it can't happen automatically. Option B is the simplest and easiest for Community members as it requires no work on their part. Option C is the most secure, but it does require pull requests to be made against a specific branch that is not the default branch. It is possible to change the default branch , which is the default branch used for PRs, but it is also the default branch used for git clone and displayed on the web interface. Reusable workflows are workflow yaml files that can be reused in repositories. Should strongly prefer to use reusable workflows in CI: Reduces technical debt in CI (improvements automatically propagated to all CI) Isolates major CI changes to a repository with much higher security Less error prone Possibility of running CI checks for changes to GitHub workflow configuration.","title":"GitHub"},{"location":"technical/reproducibility_and_performance_testing_organisation/#hpc-runners","text":"Run as a service user. Reduces the potential for harmful attack and inadvertent changes to a user environment which may introduce more attack possibilities. Also reduces the damage in the case of account compromise. Run entirely in ephemeral PBS jobfs space. Reduces the potential for harmful or malicious artefacts to persist and be reused. Use automated pre-run script to make some consistency checks, e.g. job name matches allowed list. This has the advantage of being completely independent of the repository code, and not visible to malicious actors. This also means the script needs to be kept in sync with tests, but this is a feature not a bug: can't just run new tests without some oversight. Could have a post-run script in the same way, which is an opportunity to run some security checks. Singularity containers can be used at NCI . Containers can reduce the attack surface for malicious code, particularly using user-bind to create read-only mounts. Use automated post-run script to do post-run audit. Could reduce privileges of service user to prevent writing, or deleting, from important directory trees. This is problematic, as it is fragile and prone to inadvertent change. It should not be relied upon, so should probably not be used.","title":"HPC (Runners)"},{"location":"technical/reproducibility_and_performance_testing_organisation/#auditing","text":"Log information on files generated, runtime and memory usage to spot anomalous activity. Run cron workflows to check repo settings are correct.","title":"Auditing"}]}